# -*- coding: utf-8 -*-
# (c) 18Turbo, 2022

__Name__ = 'SketchApoyado'
__Comment__ = 'Create an INDEPENDENT sketch supported by a face'
__Author__ = '18Turbo'
__Version__ = '0.0.1'
__Date__ = '2022-09-14'
__License__ = 'LGPL-2.0-or-later'
__Web__ = 'https://github.com/18turbo/sketchApoyadoFreeCAD'
__Wiki__ = 'https://github.com/18turbo/sketchApoyadoFreeCAD'
__Icon__ = 'https://github.com/18turbo/sketchApoyadoFreeCAD/blob/main/sketchAp/icons/sketchApoyado.svg'
__Help__ = ''
__Status__ = 'beta'
__Requires__ = 'FreeCAD >= v0.20'
__Contact__ = 'https://github.com/18turbo'
__Communication__ = ''
__Files__ = 'sketchAp/icons/sketchApoyado.svg,sketchAp/icons/sketchApoyadoActualizar.svg'
__Files__ += 'SketchAp.FCMacro,SketchApUpdate.FCMacro'


# (En español:)
# Funcionalidad:    Actualiza la posición de un sketch hecho con SketchAp, seleccionando la nueva cara y el plano de referencia
#
# Nota importante: Basado en el script de *** Sebastián Ernesto García ***
#
# Agradecimientos: Sebastián Ernesto García


import FreeCAD as App
import FreeCADGui as Gui

from numpy import array, eye, pi

sel = Gui.Selection.getSelectionEx()

if len(sel) == 2:

    sel1 = sel[0]
    sel2 = sel[1]

    flag = False
    if sel1.Object.TypeId == 'Part::Plane':
        datumPlane = sel1.Object
        subobjs = sel2.SubObjects
        flag = True
    elif sel2.Object.TypeId == 'Part::Plane':
        datumPlane = sel2.Object
        subobjs = sel1.SubObjects
        flag = True

    if flag == True:
        if len(subobjs) == 1:
            face = subobjs[0]
            if face.ShapeType == 'Face':
                normalDatum = face.normalAt(0,0)
                if normalDatum.z < 0:
                    normalXY = App.Vector(0, 0, -1)
                else:
                    normalXY = App.Vector(0, 0, 1)
                v = normalXY.cross(normalDatum)
                epsilon = 0.0000000001
                if v.Length > epsilon:
                    c = normalXY.dot(normalDatum)
                    s = v.normalize()
                    vx = array([[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]])
                    R = eye(3) + vx + vx.dot(vx) * ((1 - c) / (s.dot(s)))
                    rotation = App.Rotation(*R.reshape(9))
                    datumPlane.Placement = App.Placement( App.Vector(face.BoundBox.XMin, face.BoundBox.YMin, face.BoundBox.ZMin) ,App.Rotation(rotation.Axis, rotation.Angle * 180 / pi))
                else:
                    datumPlane.Placement = App.Placement( App.Vector(face.BoundBox.XMin, face.BoundBox.YMin, face.BoundBox.ZMin) ,App.Rotation(App.Vector(0,0,0), 0) )
                datumPlane.recompute()
            else:
                App.Console.PrintWarning("Debes elegir una cara y un Plano de Referencia\n")
        else:
            App.Console.PrintWarning("Debes elegir una cara y un Plano de Referencia\n")
    else:
        App.Console.PrintWarning("Debes elegir una cara y un Plano de Referencia\n")
else:
    App.Console.PrintWarning("Debes elegir una cara y un Plano de Referencia\n")